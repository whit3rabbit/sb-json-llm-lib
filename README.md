# sb-json-llm-lib

This is used for finetuning LLM dataset generation. It may not be useful outside of that.

It takes a json of selenium selectors and HTML of source. It returns types and tests to validate if seleniumbase can process them.

A Python library for parsing, validating, and testing Seleniumbase selectors generated by LLMs. This library integrates with SeleniumBase to offer real browser-based testing of selectors.

## Features

- **Selector Parsing & Validation:** Parse selectors from JSON and validate them for CSS, XPath, ID, Class, and Tag.
- **Browser-Based Testing:** Leverage SeleniumBase to perform live tests on selectors against actual HTML pages.
- **Content Extraction:** Extract content from HTML elements using validated selectors.
- **Selector Specificity Calculation:** Compute the specificity of CSS selectors to help with debugging and optimization.
- **Comprehensive Error Handling:** In-depth error feedback for invalid selectors, HTML content, and JSON input.

## Installation

Install directly from GitHub:

```bash
pip install git+https://github.com/whit3rabbit/sb-json-llm-lib.git
```

## Usage

### Basic Usage

```python
from selenium_selector_parser import SelectorParser

# Initialize parser
parser = SelectorParser()

# Parse selectors from a JSON string
selectors = parser.parse_json_string('{"title_selector": "h1.title"}')

# Parse selectors from a JSON file
selectors = parser.parse_json_file('selectors.json')

# Parse and validate selectors against HTML content with browser testing
selectors = parser.parse_and_validate(
    json_data='{"title_selector": "h1.title"}',
    html_content='<h1 class="title">Hello</h1>'
)
```

### Advanced Usage

```python
# Define multiple selectors for different content elements
selectors = {
    "title_selector": "h1.article-title",
    "author_selector": "//div[@class='author']",  # XPath selector
    "date_selector": "#publish-date",             # ID selector
    "content_selector": "article.content p"        # CSS selector
}

html_content = """
<html>
    <h1 class="article-title">Test Article</h1>
    <div class="author">John Doe</div>
    <div id="publish-date">2024-01-11</div>
    <article class="content">
        <p>Article content here</p>
    </article>
</html>
"""

# Parse and validate selectors with browser testing and content extraction
results = parser.parse_and_validate(selectors, html_content)

# Inspect validation results
for field, info in results["html_validation"].items():
    print(f"\n{field}:")
    print(f"  Found: {info['found']}")
    print(f"  Content: {info['content']}")
```

## Return Formats

### From `parse_json_string` & `parse_json_file`

These methods return a **Python dictionary** with the following structure:

- **`processed_selectors`:** A dictionary where each key is a selector field (e.g., `"title_selector"`) and its value contains:
  - **`type`**: The type of selector (e.g., `"css selector"`, `"xpath"`, `"id"`, etc.).
  - **`processed`**: The normalized version of the selector.
  - **`is_valid`**: A boolean indicating if the selector passed validation.
  - **`message`**: A validation message (could be an error or informational note for empty selectors).
  - **`specificity`**: A tuple representing the CSS specificity (for example, `(1, 2, 1)`).
- **`all_valid`:** A boolean value that is `True` only if all provided selectors are valid.

### From `parse_and_validate`

This method returns a similar dictionary with an additional key:

- **`html_validation`:** A dictionary where each key corresponds to a selector field. Each value is another dictionary with:
  - **`found`**: A boolean indicating whether the element was found in the provided HTML via SeleniumBase.
  - **`status`**: A message detailing the result of the browser test.
  - **`content`**: The text content extracted from the matching HTML element (if any).

These return formats allow you to easily inspect both the pre-validation processing and the runtime validation (browser-based testing) results. You can also convert the data to JSON if needed.

## Supported Selector Types

- **CSS Selectors:** e.g., `h1.title`, `div > p`
- **XPath Selectors:** e.g., `//div[@class='author']`
- **ID Selectors:** e.g., `#main`
- **Class Selectors:** e.g., `.header`
- **Tag Selectors:** e.g., `div`, `span`

## Development

To set up for development:

```bash
# Clone the repository
git clone https://github.com/whit3rabbit/sb-json-llm-lib.git
cd sb-json-llm-lib

# Create and activate a virtual environment
python -m venv venv
source venv/bin/activate  # On Windows use: venv\Scripts\activate

# Install development dependencies
pip install -e ".[dev]"

# Run tests
pytest tests/

# Run tests with coverage report
pytest --cov=selenium_selector_parser tests/

# Run a specific test file
pytest tests/test_parser.py -v
```

## Requirements

- Python 3.7+
- [SeleniumBase](https://github.com/seleniumbase/SeleniumBase)
- [pydantic](https://pydantic-docs.helpmanual.io/)
- [lxml](https://lxml.de/)
- [cssselect](https://cssselect.readthedocs.io/)
- [tinycss2](https://tinycss2.readthedocs.io/)

## License

This project is licensed under the MIT License â€“ see the [LICENSE](LICENSE) file for details.

## Additional Notes

- **Browser Testing:** The library uses SeleniumBase to test selectors in real browsers. To run these tests, use the `--run-browser` flag with pytest.
- **Error Handling:** You'll receive detailed error messages for issues with selectors, HTML content, or JSON parsing.
- **Static vs. Dynamic Validation:** The library supports both pre-parsed (static) validation and dynamic content extraction from live HTML pages.
