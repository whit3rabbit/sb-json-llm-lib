# sb-json-llm-lib

This is used for finetuning LLM dataset generation. It may not be useful outside of that.

It takes a JSON of Selenium selectors and HTML of source. It returns types and tests to validate if SeleniumBase can process them.

A Python library for parsing, validating, and testing SeleniumBase selectors generated by LLMs. This library integrates with SeleniumBase to offer real browser-based testing of selectors.

## Features

- **Selector Parsing & Validation:** Parse selectors from JSON and validate them for CSS, XPath, ID, Class, and Tag.
- **Browser-Based Testing:** Leverage SeleniumBase to perform live tests on selectors against actual HTML pages.
- **Content Extraction:** Extract content from HTML elements using validated selectors.
- **Selector Specificity Calculation:** Compute the specificity of CSS selectors to help with debugging and optimization.
- **Comprehensive Error Handling:** In-depth error feedback for invalid selectors, HTML content, and JSON input.
- **URL Field Support:** An extra `url` key in your JSON input is passed through directly without selector normalization or validation.

## Installation

Install directly from GitHub:

```bash
pip install git+https://github.com/whit3rabbit/sb-json-llm-lib.git
```

## Expected JSON Input Format

The JSON data should represent a dictionary where each key is a name (or identifier) for the selector and each value is the selector string itself. In addition, you can include a `url` key to provide a URL associated with the selectors. The parser processes only the expected selector keys and passes the `url` field through without modification.

**Example JSON:**

```json
{
  "title_selector": "h1.article-title",
  "author_selector": "//div[@class='author']",
  "date_selector": "#publish-date",
  "content_selector": "article.content p",
  "url": "http://webpage"
}
```

## Usage

### Basic Usage

```python
from selenium_selector_parser import SelectorParser

# Initialize parser
parser = SelectorParser()

# Parse selectors from a JSON string
selectors = parser.parse_json_string('{"title_selector": "h1.title"}')

# Parse selectors from a JSON file
selectors = parser.parse_json_file('selectors.json')

# Parse and validate selectors against HTML content with browser testing
selectors = parser.parse_and_validate(
    json_data='{"title_selector": "h1.title", "url": "http://webpage"}',
    html_content='<h1 class="title">Hello</h1>'
)
```

### Advanced Usage

```python
# Define multiple selectors for different content elements and include a URL
selectors = {
    "title_selector": "h1.article-title",
    "author_selector": "//div[@class='author']",  # XPath selector
    "date_selector": "#publish-date",             # ID selector
    "content_selector": "article.content p",        # CSS selector
    "url": "http://webpage"
}

html_content = """
<html>
    <h1 class="article-title">Test Article</h1>
    <div class="author">John Doe</div>
    <div id="publish-date">2024-01-11</div>
    <article class="content">
        <p>Article content here</p>
    </article>
</html>
"""

# Parse and validate selectors with browser testing and content extraction
results = parser.parse_and_validate(selectors, html_content)

# Inspect validation results
for field, info in results["html_validation"].items():
    print(f"\n{field}:")
    print(f"  Found: {info['found']}")
    print(f"  Content: {info['content']}")
```

## Return Formats

### From `parse_json_string` & `parse_json_file`

These methods return a **Python dictionary** with the following structure:

- **`processed_selectors`:** A dictionary where each key is a selector field (e.g., `"title_selector"`) and its value contains:
  - **`type`**: The type of selector (e.g., `"css selector"`, `"xpath"`, `"id"`, etc.).
  - **`processed`**: The normalized version of the selector.
  - **`is_valid`**: A boolean indicating if the selector passed validation.
  - **`message`**: A validation message (could be an error or informational note for empty selectors).
  - **`specificity`**: A tuple representing the CSS specificity (for example, `(1, 2, 1)`).
- **`all_valid`:** A boolean value that is `True` only if all provided selectors are valid.

*Note:* The `url` key is simply passed through in `processed_selectors` without modification.

### From `parse_and_validate`

This method returns a similar dictionary with an additional key:

- **`html_validation`:** A dictionary where each key corresponds to a selector field. Each value is another dictionary with:
  - **`found`**: A boolean indicating whether the element was found in the provided HTML via SeleniumBase.
  - **`status`**: A message detailing the result of the browser test.
  - **`content`**: The text content extracted from the matching HTML element (if any).

These return formats allow you to easily inspect both the pre-validation processing and the runtime validation (browser-based testing) results.

## Output Examples

### JSON Output

You can convert the returned dictionary to JSON for storage or further processing:

```python
import json

# Assuming 'results' is the dictionary returned from parse_and_validate
json_output = json.dumps(results, indent=2)
print(json_output)
```

**Example JSON Output:**

```json
{
  "processed_selectors": {
    "title_selector": {
      "type": "css selector",
      "processed": "h1.article-title",
      "is_valid": true,
      "message": "",
      "specificity": [0, 1, 1]
    },
    "author_selector": {
      "type": "xpath",
      "processed": "//div[@class='author']",
      "is_valid": true,
      "message": "",
      "specificity": [0, 0, 0]
    },
    "date_selector": {
      "type": "id",
      "processed": "publish-date",
      "is_valid": true,
      "message": "",
      "specificity": [1, 0, 0]
    },
    "content_selector": {
      "type": "css selector",
      "processed": "article.content p",
      "is_valid": true,
      "message": "",
      "specificity": [0, 1, 1]
    },
    "url": "http://webpage"
  },
  "all_valid": true,
  "html_validation": {
    "title_selector": {
      "found": true,
      "status": "Element found and visible",
      "content": "Test Article"
    },
    "author_selector": {
      "found": true,
      "status": "Element found and visible",
      "content": "John Doe"
    },
    "date_selector": {
      "found": true,
      "status": "Element found and visible",
      "content": "2024-01-11"
    },
    "content_selector": {
      "found": true,
      "status": "Element found and visible",
      "content": "Article content here"
    }
  }
}
```

### CSV Output

If you need a CSV output, you can convert the results to CSV. For example, you might extract a flat version of the HTML validation results:

```python
import csv

# Open a CSV file for writing
with open('validation_results.csv', mode='w', newline='') as csv_file:
    fieldnames = ['selector_field', 'found', 'status', 'content']
    writer = csv.DictWriter(csv_file, fieldnames=fieldnames)
    
    writer.writeheader()
    for field, info in results["html_validation"].items():
        writer.writerow({
            'selector_field': field,
            'found': info['found'],
            'status': info['status'],
            'content': info['content']
        })
```

This script writes the HTML validation details to `validation_results.csv`.

## Supported Selector Types

- **CSS Selectors:** e.g., `h1.title`, `div > p`
- **XPath Selectors:** e.g., `//div[@class='author']`
- **ID Selectors:** e.g., `#main`
- **Class Selectors:** e.g., `.header`
- **Tag Selectors:** e.g., `div`, `span`

## Development

To set up for development:

```bash
# Clone the repository
git clone https://github.com/whit3rabbit/sb-json-llm-lib.git
cd sb-json-llm-lib

# Create and activate a virtual environment
python -m venv venv
source venv/bin/activate  # On Windows use: venv\Scripts\activate

# Install development dependencies
pip install -e ".[dev]"

# Run tests
pytest tests/

# Run tests with coverage report
pytest --cov=selenium_selector_parser tests/

# Run a specific test file
pytest tests/test_parser.py -v
```

## Requirements

- Python 3.7+
- [SeleniumBase](https://github.com/seleniumbase/SeleniumBase)
- [pydantic](https://pydantic-docs.helpmanual.io/)
- [lxml](https://lxml.de/)
- [cssselect](https://cssselect.readthedocs.io/)
- [tinycss2](https://tinycss2.readthedocs.io/)

## License

This project is licensed under the MIT License â€“ see the [LICENSE](LICENSE) file for details.

## Additional Notes

- **Browser Testing:** The library uses SeleniumBase to test selectors in real browsers. To run these tests, use the `--run-browser` flag with pytest.
- **Error Handling:** You'll receive detailed error messages for issues with selectors, HTML content, or JSON parsing.
- **Static vs. Dynamic Validation:** The library supports both pre-parsed (static) validation and dynamic content extraction from live HTML pages.
